From: Nicolai Stange <nstange@suse.de>
Subject: kABI: provide compatibility wrappers for debugfs removal protection API
Patch-mainline: Never, kABI
References: bsc#1159198 bsc#1109911

Upstream commit 1b19cb68fc8a ("debugfs: implement per-file removal
protection"), imported as
patches.suse/debugfs-implement-per-file-removal-protection.patch,
replaces the former debugfs_use_file_start() and debugfs_use_file_finish()
by the new debugfs_file_get() and debugfs_file_put().

Both pairs are supposed to be used from debugfs files' file_operations
handlers to protect against concurrent file removal. However, the
signatures of the new pair is different from the old ones', in particular,
debugfs_file_put() needs access to the dentry in question, but the old
debugfs_use_file_finish() didn't take one as an argument.

Reintroduce debugfs_use_file_start() and debugfs_use_file_finish(), but
turn them into nops. This renders removal protection measures implemented
in (external) modules' file_operations handlers ineffective. In order to
work around this, force debugfs' fully lifetime managing proxy,
debugfs_full_proxy_file_operations, on them.

To this end, rename debugfs_create_file_unsafe(), i.e. the primitive
installing only the lightweight "open proxy", to
"__debugfs_create_file_unsafe()". Provide a compatibility implementation
of  debugfs_create_file_unsafe() forwarding to debugfs_create_file(), i.e.
to the primitive wrapping the provided file_operations with the fully
protecting proxy. Thus, modules that used to call
debugfs_create_file_unsafe() will now effectively be redirected to
debugfs_create_file().

The debugfs core itself has been converted to the new API, so let it use
the more lightweight __debugfs_create_file_unsafe() where appropriate.
Similarly, all user-provided file_operations defined by means of
DEFINE_DEBUGFS_ATTRIBUTE() are good. As this is the common case, make the
debugfs_create_file_unsafe() compatibility wrapper detect it and
forward those to the __debugfs_create_file_unsafe() variant as an
optimization.

Signed-off-by: Nicolai Stange <nstange@suse.de>

---
 fs/debugfs/file.c       |   38 ++++++++++++++++++++++++++++++++++++++
 fs/debugfs/inode.c      |   41 ++++++++++++++++++++++++++++++++++++++++-
 include/linux/debugfs.h |    4 ++++
 3 files changed, 82 insertions(+), 1 deletion(-)

--- a/fs/debugfs/file.c
+++ b/fs/debugfs/file.c
@@ -47,6 +47,44 @@ const struct file_operations debugfs_noo
 	.llseek =	noop_llseek,
 };
 
+/* kABI compatibility wrapper */
+int debugfs_use_file_start(const struct dentry *dentry, int *srcu_idx)
+{
+	/*
+	 * Make this a nop, remaining non-debugfs core users will get the
+	 * full proxy debugfs_full_proxy_file_operations forced on them,
+	 * c.f. the adapted debugfs_create_file_unsafe() compatibility
+	 * wrapper.
+	 */
+	return 0;
+}
+EXPORT_SYMBOL_GPL(debugfs_use_file_start);
+
+/* kABI compatibility wrapper */
+void debugfs_use_file_finish(int srcu_idx)
+{
+	/*
+	 * Make this a nop, c.f. the comment in debugfs_use_file_start()
+	 * above.
+	 */
+}
+EXPORT_SYMBOL_GPL(debugfs_use_file_finish);
+
+/*
+ * kABI compatibility: debugfs_use_file_start() and
+ * debugfs_use_file_finish() have been superseded by debugfs_file_get()
+ * and debugfs_file_put() respectively. All callers in this file have
+ * have been converted and there's no need for them to always get
+ * the full debugfs_full_proxy_file_operations imposed on them.
+ * Make them all use __debugfs_create_file_unsafe(), which corresponds
+ * 1:1 to upstream's debugfs_create_file_unsafe().
+ */
+struct dentry *__debugfs_create_file_unsafe(const char *name, umode_t mode,
+				   struct dentry *parent, void *data,
+				   const struct file_operations *fops);
+#define debugfs_create_file_unsafe __debugfs_create_file_unsafe
+
+
 #define F_DENTRY(filp) ((filp)->f_path.dentry)
 
 const struct file_operations *debugfs_real_fops(const struct file *filp)
--- a/fs/debugfs/inode.c
+++ b/fs/debugfs/inode.c
@@ -454,7 +454,7 @@ EXPORT_SYMBOL_GPL(debugfs_create_file);
  * DEFINE_DEBUGFS_ATTRIBUTE() is protected against file removals and
  * thus, may be used here.
  */
-struct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,
+struct dentry *__debugfs_create_file_unsafe(const char *name, umode_t mode,
 				   struct dentry *parent, void *data,
 				   const struct file_operations *fops)
 {
@@ -464,6 +464,45 @@ struct dentry *debugfs_create_file_unsaf
 					&debugfs_noop_file_operations,
 				fops);
 }
+
+/*
+ * kABI compatibility wrapper: the original implementation from above
+ * corresponding 1:1 to upstream has been renamed.
+ */
+struct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,
+				   struct dentry *parent, void *data,
+				   const struct file_operations *fops)
+{
+	/*
+	 * This gets invoked from users outside of the debugfs core only.
+	 * Handle the case where users of the obsolete debugfs_use_file_start()
+	 * resp. debugfs_use_file_finish() (which are now nops) haven't been
+	 * converted to the new debugfs_file_get()/debugfs_file_put() API.
+	 * Protect their fops against file removal by wrapping them with a
+	 * debugfs_full_proxy_file_operations, i.e. simply forward this call
+	 * here to debugfs_create_file().
+	 * There are two cases:
+	 * 1.) The file_operations instance has been defined by means of the
+	 *     DEFINE_DEBUGFS_ATTRIBUTE() macro. In this case, all fops handlers
+	 *     are provided by the debugfs core itself and have been converted.
+	 *     This is the common case; in order to avoid the full proxy
+	 *     overhead, check for this and don't install the full proxy if
+	 *     positive.
+	 * 2.) All other cases, where the custom file_operation's handlers
+	 *     possibly implement their own file removal protection on the
+	 *     grounds of debugfs_use_file_start()/-_finish(). As their
+	 *     protection has become ineffective now, wrap them with
+	 *     the full proxy.
+	 */
+	if (fops && fops->read == debugfs_attr_read) {
+		/* This is safe, it's a DEFINE_DEBUGFS_ATTRIBUTE() fops. */
+		return __debugfs_create_file_unsafe(name, mode, parent, data,
+						    fops);
+	} else {
+		/* Not known to be safe, wrap it. */
+		return debugfs_create_file(name, mode, parent, data, fops);
+	}
+}
 EXPORT_SYMBOL_GPL(debugfs_create_file_unsafe);
 
 /**
--- a/include/linux/debugfs.h
+++ b/include/linux/debugfs.h
@@ -87,6 +87,10 @@ struct dentry *debugfs_create_automount(
 void debugfs_remove(struct dentry *dentry);
 #define debugfs_remove_recursive debugfs_remove
 
+/* kABI compatibility dummies */
+int debugfs_use_file_start(const struct dentry *dentry, int *srcu_idx);
+void debugfs_use_file_finish(int srcu_idx);
+
 const struct file_operations *debugfs_real_fops(const struct file *filp);
 
 int debugfs_file_get(struct dentry *dentry);
