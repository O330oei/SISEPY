From: Gary Lin <glin@suse.com>
Subject: [PATCH] kabi: invoke bpf_gen_ld_abs() directly
Patch-mainline: No, SUSE-specific
References: bsc#1158552

e0cea7ce988c introduced a member, gen_ld_abs, to bpf_verifier_ops which
is in the middle of bpf_verifier_env. Since nfp also uses bpf_verifier_env,
changing the members of bpf_verifier_env would break KABI. To unbreak KABI,
this patch exports bpf_gen_ld_abs() so that bpf verifier can use it directly.
Since gen_ld_abs is only available for sk_filter and tc_cls/act, the check
for gen_ld_abs is replaced with the check for the program type,
BPF_PROG_TYPE_SOCKET_FILTER, BPF_PROG_TYPE_SCHED_CLS, and BPF_PROG_TYPE_SCHED_ACT.

Signed-off-by: Gary Lin <glin@suse.com>
---
 include/linux/bpf.h    |    2 --
 include/linux/filter.h |    1 +
 kernel/bpf/verifier.c  |    6 ++++--
 net/core/filter.c      |    7 +++----
 4 files changed, 8 insertions(+), 8 deletions(-)

--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -172,8 +172,6 @@ struct bpf_verifier_ops {
 				struct bpf_insn_access_aux *info);
 	int (*gen_prologue)(struct bpf_insn *insn, bool direct_write,
 			    const struct bpf_prog *prog);
-	int (*gen_ld_abs)(const struct bpf_insn *orig,
-			  struct bpf_insn *insn_buf);
 	u32 (*convert_ctx_access)(enum bpf_access_type type,
 				  const struct bpf_insn *src,
 				  struct bpf_insn *dst,
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -671,6 +671,7 @@ static inline int sk_filter(struct sock
 	return sk_filter_trim_cap(sk, skb, 1);
 }
 
+int bpf_gen_ld_abs(const struct bpf_insn *orig, struct bpf_insn *insn_buf);
 struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err);
 void bpf_prog_free(struct bpf_prog *fp);
 
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -3309,7 +3309,9 @@ static int check_ld_abs(struct bpf_verif
 		return -EINVAL;
 	}
 
-	if (!env->ops->gen_ld_abs) {
+	if (env->prog->type != BPF_PROG_TYPE_SOCKET_FILTER &&
+	    env->prog->type != BPF_PROG_TYPE_SCHED_CLS &&
+	    env->prog->type != BPF_PROG_TYPE_SCHED_ACT) {
 		verbose(env, "bpf verifier is misconfigured\n");
 		return -EINVAL;
 	}
@@ -4695,7 +4697,7 @@ static int fixup_bpf_calls(struct bpf_ve
 		if (BPF_CLASS(insn->code) == BPF_LD &&
 		    (BPF_MODE(insn->code) == BPF_ABS ||
 		     BPF_MODE(insn->code) == BPF_IND)) {
-			cnt = env->ops->gen_ld_abs(insn, insn_buf);
+			cnt = bpf_gen_ld_abs(insn, insn_buf);
 			if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {
 				verbose(env, "bpf verifier is misconfigured\n");
 				return -EINVAL;
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -3199,8 +3199,8 @@ static bool sock_filter_is_valid_access(
 	return true;
 }
 
-static int bpf_gen_ld_abs(const struct bpf_insn *orig,
-			  struct bpf_insn *insn_buf)
+int bpf_gen_ld_abs(const struct bpf_insn *orig,
+		   struct bpf_insn *insn_buf)
 {
 	bool indirect = BPF_MODE(orig->code) == BPF_IND;
 	struct bpf_insn *insn = insn_buf;
@@ -3233,6 +3233,7 @@ static int bpf_gen_ld_abs(const struct b
 
 	return insn - insn_buf;
 }
+EXPORT_SYMBOL(bpf_gen_ld_abs);
 
 static int tc_cls_act_prologue(struct bpf_insn *insn_buf, bool direct_write,
 			       const struct bpf_prog *prog)
@@ -3658,7 +3659,6 @@ const struct bpf_verifier_ops sk_filter_
 	.get_func_proto		= sk_filter_func_proto,
 	.is_valid_access	= sk_filter_is_valid_access,
 	.convert_ctx_access	= bpf_convert_ctx_access,
-	.gen_ld_abs		= bpf_gen_ld_abs,
 };
 
 const struct bpf_prog_ops sk_filter_prog_ops = {
@@ -3669,7 +3669,6 @@ const struct bpf_verifier_ops tc_cls_act
 	.is_valid_access	= tc_cls_act_is_valid_access,
 	.convert_ctx_access	= tc_cls_act_convert_ctx_access,
 	.gen_prologue		= tc_cls_act_prologue,
-	.gen_ld_abs		= bpf_gen_ld_abs,
 };
 
 const struct bpf_verifier_ops tc_cls_act_analyzer_ops = {
